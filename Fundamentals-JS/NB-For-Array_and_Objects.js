// ** ARRAY ** //

Array.map();
// Създава нов масив, към всеки елемет, от който прилага функцията поставена в скобите. 

Array.split();
// 

Array.splice();
// 


// ******* OBJECTS ******* //

let object = {key: 'value', key: 'value', key: 'value'};
// Стздаваме обект. 

let object = {};
// Създава празен обект. Пример: let cat = {};

cat.name = 'Pesho';
// Един от начините да добавяме неща към обект.
// Към името на променливата, която държи целия обект, добавяме с точка името на пропъртито,
// след което с '=' добавяме стойността. Така вече създадения празем насив ридобива нов облик: 
// cat = {name: 'Pesho'};

cat['name'] = 'Pesho';
// Алтернативен синтаксис на добавяне на пропътита към обект. 

// Към масивите можем да добавяме и функционалност, която в контекста на обекти се нарича методи. 
// има няколко начина да се съзадде този метод. 
// 1.
function makeCatSound() {
    console.log('Meow');
} 
let cat = {
    name: 'Pesho', 
    age: 3, 
    makeSound: makeCatSound
};

    
    // 2. 
    let cat = {
        name: 'Pesho', 
        age: 3, 
        makeSound: function () {
            console.log('Meow')
        }
    };
    
    // 3. 
    let cat = {
        name: 'Pesho',
        age: 3, 
        makeSound: () => console.log('Meow')
    };
    
    // така се извиква метод от обект.
    cat.makeSound();

    // 4. 
    let cat = {
        name: "Navcho",
        age: 5,
        makeSound() {
            console.log('Meow');
        }
    }

    cat.makeSound();


    // Динамично добавяне на метод към съществуващ обелт.
    cat.makeSound = function() {
        console.log('Meow');
    }

    // А ето така можем да създаваме масив, от стойностите на променливи. 
    let item = 'flour';
    let quantity = 15;

    let result = { [item]: quantity }; // Ще върне {flour: 15};
    
    // друг запис: 
    let item = 'flour';
    let quantity = 15;
    
    let result = {};
    result[item] = quantity; // резулаттът ще е същия.



    // Методи към обекти

    // Връща масив с включени всички пропъртита като стрингове. 
    Object.keys(cat);  // В случая за обекта cat ще върне ['name', 'age', 'breed']

    // Връща масив с включени стойностите на всички пропъртита. 
    Object.values(cat); // В случая за обекта cat ще върне ['Navcho', 5, 'Persian']

    // Връща масив с включени двойни масиви, в които имаме като първи елемент пропъртито, а като втори - неговата стойност.
    Object.entries(cat); 
    // В случая за обекта cat ще върне [ ['name', 'Navcho'], ['age', 5], ['breed', 'Persian'] ]


    // Как можем да итерираме един обект 
    // Обект можем да итерираме с помощта на for-in цикъла. 
    // като за рзлика от масивите, където минава по индексита, в обекта минава по key-овете. 

    for (let prop in cat) {
        console.log(prop);
    }

    // А ако искаме да достъпим стойността на тези пропъртита:
    for (let prop in cat) {
        console.log(cat[prop]);
    }

    // Спредоператор

    // Със спред оператор може да се клонира даден масив. 
    // Спредоператор означава, че ще хване и ще спредне всички елементи на масива. 
    // Как става това: 
    let numbers = [1, 2, 3, 4, 5, 6, 7]
    let clonedNumbers = [...numbers]; // това вече е копие на първия масив. 

    // Друг случай, в който може да се използва: 
    let numbers = [1, 2, 3];
    function classLaptop(a, b, c) {
        console.log(a);
        console.log(b);
        console.log(c);
    }

    classLaptop(...numbers);
    // В дадения пример, когато функцията е зададена с параметри, а не с масив, 
    // вместо да изписваме всеки елемент numbers[0], numbers[1]... можем да използваме 
    // спредоператора, за да спреднев всички стойности. 

    // Спредоператора може да се използва и за обекти. 
    let person = {name: 'Pesho', age: 30};
    let otherperson = {...person}.splice
    // по този начин можем да създаваме копие на обект. 



    // Рест оператор
    // той пък е обратното, той събира множество елементи в едно. 
    function classLaptop (...numbers) {
        console.log(numbers);
    }

    classLaptop(1, 2, 3, 4, 5, 6, 7)
    // В този случай, когато една функция е зададена с аргументи, които, обаче, искаме да обединим
    // в един масив, можем да използваме рест оператора, който ще вземе, подадените аргументи
    // и ще създаде масив от тях, записан под променливата numbers. 
    // резултатът ще е [1, 2, 3, 4, 5, 6, 7].


    // Array Destructuring Asignment 
    // Използва за създаването на повече от една променлива. 
    // Пример:
    let numbers = [1, 2, 3, 4];
    let [firstNumber, secondNumber, thirdNumber] = numbers;
    // т.е. така създавам три променливи, на които закачам поредната стойност от масива. 
    // fisrtNumber = 1 (numbers[0]); secondNumber = 2 (numbers[1]); и т.н.
    
    // а за по-напредналите може и това: 
    let numbers = [1, 2, 3, 4, 5, 6];
    let [firstNum, secondNum, ... rest] = numbers; 
    // В този случай създавам две променливи, а остатъка от масива, ще се запише в трета такава като нов масив. 
    // firstNum = 1, secondNum = 2, rest = [3, 4, 5, 6];


    // Object Destructuring Asignment 
    let person = {name: 'Pesho', age: 30};

    let {name, age} = person;
    // специфичното тук е, че ако разменя местата на {name, age} и го направя {age, name},
    // то няма да запише на age - Pesho и на name - 30, а методът търси точно конкретния key
    // и записва неговата стойност като променлива. 
    // съответно ако на let {name, age}, зададем несъществуващо в обекта кий, ще ни даде undefined.
    // т.е. трябва да знаем как се казват пропъртитата, за да ги извадим, докато при масива, това не се налага. 


    // JSON = Java Script Object Notation
    // Много известен стандарт за представяне на текстово представени данни. 

    let person = {
        age: 30, 
        name: 'Pesho',
        isChild: false
    }

    JSON.stringify(person); // Взима един обект и го прави в JSON формат, дефакто в стринг. 
    // ако го запазя в променлива:
    let personString = JSON.stringify(person);

    JSON.parse(personString) // Прави обратното, взима стринг във формата JSON и го обръща в обект. 
    // важно е да се знае, ще ако стринга не е в JSON формат, метода ще гръмне и няма да върне обект. 




    // ***** CLASSES ***** // 
    // класовете са шаблони за създаване на обекти. 
    // обекта който създаваме от определен клас (шаблон) се нарича инстаниця
    // всеки клас си има конструктор, който е някакъв вид функционалност, която се извиква за да създаде обект. 
    // Класовете се пишат С ГЛАВНА БУКВА 
    // Синтаксис: 

    class Cat {
        name = 'Pesho';
    }

    // за да създадем обект от този клас, трябва да го извикаме с помощта на ключовата дума new.
    let firstCat = new Cat();
    let secondCat = new Cat();  
    //  В паметта firstCat и secondCat са отделни обекти, които сочат към различни референции. 
    // т.е. ако променим firstCat.name = 'Gosho', тези промени ще се отразят само във firstCat.
    
    // За да можем да получаваме различни обекти, според подадените данни, на помощ се включва конструктора.
    class Cat {
        name = '';
        breed = '';
        hasFut = true;

        constructor(name, breed) {
            this.name = name;
            this.breed = breed;
            this.makeSound = function() {
                console.log(`${this.name} - Meow`);
            }
        }

        // Или:
        //makeSound() {
        //   console.log('Meow');
        //}
    } 

    let firstCat = new Cat('Pesho', 'Pesian');
    let secondCat = new Cat('Navcho', 'Angora');